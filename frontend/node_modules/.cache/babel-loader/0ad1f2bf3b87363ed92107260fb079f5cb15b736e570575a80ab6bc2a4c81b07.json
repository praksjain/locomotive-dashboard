{"ast":null,"code":"import { Color, FrontSide, Matrix4, Mesh, PerspectiveCamera, Plane, ShaderMaterial, UniformsLib, UniformsUtils, Vector3, Vector4, WebGLRenderTarget } from 'three';\n\n/**\n * Work based on :\n * https://github.com/Slayvin: Flat mirror for three.js\n * https://home.adelphi.edu/~stemkoski/ : An implementation of water shader based on the flat mirror\n * http://29a.ch/ && http://29a.ch/slides/2012/webglwater/ : Water shader explanations in WebGL\n */\n\nclass Water extends Mesh {\n  constructor(geometry, options = {}) {\n    super(geometry);\n    this.isWater = true;\n    const scope = this;\n    const textureWidth = options.textureWidth !== undefined ? options.textureWidth : 512;\n    const textureHeight = options.textureHeight !== undefined ? options.textureHeight : 512;\n    const clipBias = options.clipBias !== undefined ? options.clipBias : 0.0;\n    const alpha = options.alpha !== undefined ? options.alpha : 1.0;\n    const time = options.time !== undefined ? options.time : 0.0;\n    const normalSampler = options.waterNormals !== undefined ? options.waterNormals : null;\n    const sunDirection = options.sunDirection !== undefined ? options.sunDirection : new Vector3(0.70707, 0.70707, 0.0);\n    const sunColor = new Color(options.sunColor !== undefined ? options.sunColor : 0xffffff);\n    const waterColor = new Color(options.waterColor !== undefined ? options.waterColor : 0x7F7F7F);\n    const eye = options.eye !== undefined ? options.eye : new Vector3(0, 0, 0);\n    const distortionScale = options.distortionScale !== undefined ? options.distortionScale : 20.0;\n    const side = options.side !== undefined ? options.side : FrontSide;\n    const fog = options.fog !== undefined ? options.fog : false;\n\n    //\n\n    const mirrorPlane = new Plane();\n    const normal = new Vector3();\n    const mirrorWorldPosition = new Vector3();\n    const cameraWorldPosition = new Vector3();\n    const rotationMatrix = new Matrix4();\n    const lookAtPosition = new Vector3(0, 0, -1);\n    const clipPlane = new Vector4();\n    const view = new Vector3();\n    const target = new Vector3();\n    const q = new Vector4();\n    const textureMatrix = new Matrix4();\n    const mirrorCamera = new PerspectiveCamera();\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight);\n    const mirrorShader = {\n      uniforms: UniformsUtils.merge([UniformsLib['fog'], UniformsLib['lights'], {\n        'normalSampler': {\n          value: null\n        },\n        'mirrorSampler': {\n          value: null\n        },\n        'alpha': {\n          value: 1.0\n        },\n        'time': {\n          value: 0.0\n        },\n        'size': {\n          value: 1.0\n        },\n        'distortionScale': {\n          value: 20.0\n        },\n        'textureMatrix': {\n          value: new Matrix4()\n        },\n        'sunColor': {\n          value: new Color(0x7F7F7F)\n        },\n        'sunDirection': {\n          value: new Vector3(0.70707, 0.70707, 0)\n        },\n        'eye': {\n          value: new Vector3()\n        },\n        'waterColor': {\n          value: new Color(0x555555)\n        }\n      }]),\n      vertexShader: /* glsl */`\n\t\t\t\tuniform mat4 textureMatrix;\n\t\t\t\tuniform float time;\n\n\t\t\t\tvarying vec4 mirrorCoord;\n\t\t\t\tvarying vec4 worldPosition;\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <shadowmap_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tmirrorCoord = modelMatrix * vec4( position, 1.0 );\n\t\t\t\t\tworldPosition = mirrorCoord.xyzw;\n\t\t\t\t\tmirrorCoord = textureMatrix * mirrorCoord;\n\t\t\t\t\tvec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t#include <beginnormal_vertex>\n\t\t\t\t#include <defaultnormal_vertex>\n\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t#include <fog_vertex>\n\t\t\t\t#include <shadowmap_vertex>\n\t\t\t}`,\n      fragmentShader: /* glsl */`\n\t\t\t\tuniform sampler2D mirrorSampler;\n\t\t\t\tuniform float alpha;\n\t\t\t\tuniform float time;\n\t\t\t\tuniform float size;\n\t\t\t\tuniform float distortionScale;\n\t\t\t\tuniform sampler2D normalSampler;\n\t\t\t\tuniform vec3 sunColor;\n\t\t\t\tuniform vec3 sunDirection;\n\t\t\t\tuniform vec3 eye;\n\t\t\t\tuniform vec3 waterColor;\n\n\t\t\t\tvarying vec4 mirrorCoord;\n\t\t\t\tvarying vec4 worldPosition;\n\n\t\t\t\tvec4 getNoise( vec2 uv ) {\n\t\t\t\t\tvec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);\n\t\t\t\t\tvec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );\n\t\t\t\t\tvec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );\n\t\t\t\t\tvec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );\n\t\t\t\t\tvec4 noise = texture2D( normalSampler, uv0 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv1 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv2 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv3 );\n\t\t\t\t\treturn noise * 0.5 - 1.0;\n\t\t\t\t}\n\n\t\t\t\tvoid sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {\n\t\t\t\t\tvec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );\n\t\t\t\t\tfloat direction = max( 0.0, dot( eyeDirection, reflection ) );\n\t\t\t\t\tspecularColor += pow( direction, shiny ) * sunColor * spec;\n\t\t\t\t\tdiffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;\n\t\t\t\t}\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <packing>\n\t\t\t\t#include <bsdfs>\n\t\t\t\t#include <fog_pars_fragment>\n\t\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t\t#include <lights_pars_begin>\n\t\t\t\t#include <shadowmap_pars_fragment>\n\t\t\t\t#include <shadowmask_pars_fragment>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#include <logdepthbuf_fragment>\n\t\t\t\t\tvec4 noise = getNoise( worldPosition.xz * size );\n\t\t\t\t\tvec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );\n\n\t\t\t\t\tvec3 diffuseLight = vec3(0.0);\n\t\t\t\t\tvec3 specularLight = vec3(0.0);\n\n\t\t\t\t\tvec3 worldToEye = eye-worldPosition.xyz;\n\t\t\t\t\tvec3 eyeDirection = normalize( worldToEye );\n\t\t\t\t\tsunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );\n\n\t\t\t\t\tfloat distance = length(worldToEye);\n\n\t\t\t\t\tvec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;\n\t\t\t\t\tvec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );\n\n\t\t\t\t\tfloat theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );\n\t\t\t\t\tfloat rf0 = 0.3;\n\t\t\t\t\tfloat reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );\n\t\t\t\t\tvec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;\n\t\t\t\t\tvec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);\n\t\t\t\t\tvec3 outgoingLight = albedo;\n\t\t\t\t\tgl_FragColor = vec4( outgoingLight, alpha );\n\n\t\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t\t#include <fog_fragment>\n\t\t\t\t}`\n    };\n    const material = new ShaderMaterial({\n      fragmentShader: mirrorShader.fragmentShader,\n      vertexShader: mirrorShader.vertexShader,\n      uniforms: UniformsUtils.clone(mirrorShader.uniforms),\n      lights: true,\n      side: side,\n      fog: fog\n    });\n    material.uniforms['mirrorSampler'].value = renderTarget.texture;\n    material.uniforms['textureMatrix'].value = textureMatrix;\n    material.uniforms['alpha'].value = alpha;\n    material.uniforms['time'].value = time;\n    material.uniforms['normalSampler'].value = normalSampler;\n    material.uniforms['sunColor'].value = sunColor;\n    material.uniforms['waterColor'].value = waterColor;\n    material.uniforms['sunDirection'].value = sunDirection;\n    material.uniforms['distortionScale'].value = distortionScale;\n    material.uniforms['eye'].value = eye;\n    scope.material = material;\n    scope.onBeforeRender = function (renderer, scene, camera) {\n      mirrorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n      rotationMatrix.extractRotation(scope.matrixWorld);\n      normal.set(0, 0, 1);\n      normal.applyMatrix4(rotationMatrix);\n      view.subVectors(mirrorWorldPosition, cameraWorldPosition);\n\n      // Avoid rendering when mirror is facing away\n\n      if (view.dot(normal) > 0) return;\n      view.reflect(normal).negate();\n      view.add(mirrorWorldPosition);\n      rotationMatrix.extractRotation(camera.matrixWorld);\n      lookAtPosition.set(0, 0, -1);\n      lookAtPosition.applyMatrix4(rotationMatrix);\n      lookAtPosition.add(cameraWorldPosition);\n      target.subVectors(mirrorWorldPosition, lookAtPosition);\n      target.reflect(normal).negate();\n      target.add(mirrorWorldPosition);\n      mirrorCamera.position.copy(view);\n      mirrorCamera.up.set(0, 1, 0);\n      mirrorCamera.up.applyMatrix4(rotationMatrix);\n      mirrorCamera.up.reflect(normal);\n      mirrorCamera.lookAt(target);\n      mirrorCamera.far = camera.far; // Used in WebGLBackground\n\n      mirrorCamera.updateMatrixWorld();\n      mirrorCamera.projectionMatrix.copy(camera.projectionMatrix);\n\n      // Update the texture matrix\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n      textureMatrix.multiply(mirrorCamera.projectionMatrix);\n      textureMatrix.multiply(mirrorCamera.matrixWorldInverse);\n\n      // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n      // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n      mirrorPlane.setFromNormalAndCoplanarPoint(normal, mirrorWorldPosition);\n      mirrorPlane.applyMatrix4(mirrorCamera.matrixWorldInverse);\n      clipPlane.set(mirrorPlane.normal.x, mirrorPlane.normal.y, mirrorPlane.normal.z, mirrorPlane.constant);\n      const projectionMatrix = mirrorCamera.projectionMatrix;\n      q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n      q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n      q.z = -1.0;\n      q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];\n\n      // Calculate the scaled plane vector\n      clipPlane.multiplyScalar(2.0 / clipPlane.dot(q));\n\n      // Replacing the third row of the projection matrix\n      projectionMatrix.elements[2] = clipPlane.x;\n      projectionMatrix.elements[6] = clipPlane.y;\n      projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias;\n      projectionMatrix.elements[14] = clipPlane.w;\n      eye.setFromMatrixPosition(camera.matrixWorld);\n\n      // Render\n\n      const currentRenderTarget = renderer.getRenderTarget();\n      const currentXrEnabled = renderer.xr.enabled;\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      scope.visible = false;\n      renderer.xr.enabled = false; // Avoid camera modification and recursion\n      renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n      renderer.setRenderTarget(renderTarget);\n      renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n      if (renderer.autoClear === false) renderer.clear();\n      renderer.render(scene, mirrorCamera);\n      scope.visible = true;\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.setRenderTarget(currentRenderTarget);\n\n      // Restore viewport\n\n      const viewport = camera.viewport;\n      if (viewport !== undefined) {\n        renderer.state.viewport(viewport);\n      }\n    };\n  }\n}\nexport { Water };","map":{"version":3,"names":["Color","FrontSide","Matrix4","Mesh","PerspectiveCamera","Plane","ShaderMaterial","UniformsLib","UniformsUtils","Vector3","Vector4","WebGLRenderTarget","Water","constructor","geometry","options","isWater","scope","textureWidth","undefined","textureHeight","clipBias","alpha","time","normalSampler","waterNormals","sunDirection","sunColor","waterColor","eye","distortionScale","side","fog","mirrorPlane","normal","mirrorWorldPosition","cameraWorldPosition","rotationMatrix","lookAtPosition","clipPlane","view","target","q","textureMatrix","mirrorCamera","renderTarget","mirrorShader","uniforms","merge","value","vertexShader","fragmentShader","material","clone","lights","texture","onBeforeRender","renderer","scene","camera","setFromMatrixPosition","matrixWorld","extractRotation","set","applyMatrix4","subVectors","dot","reflect","negate","add","position","copy","up","lookAt","far","updateMatrixWorld","projectionMatrix","multiply","matrixWorldInverse","setFromNormalAndCoplanarPoint","x","y","z","constant","Math","sign","elements","w","multiplyScalar","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","visible","setRenderTarget","state","buffers","depth","setMask","autoClear","clear","render","viewport"],"sources":["/Users/apple/Documents/Prakhar/Projects/locomotive-simulator/frontend/node_modules/three/examples/jsm/objects/Water.js"],"sourcesContent":["import {\n\tColor,\n\tFrontSide,\n\tMatrix4,\n\tMesh,\n\tPerspectiveCamera,\n\tPlane,\n\tShaderMaterial,\n\tUniformsLib,\n\tUniformsUtils,\n\tVector3,\n\tVector4,\n\tWebGLRenderTarget\n} from 'three';\n\n/**\n * Work based on :\n * https://github.com/Slayvin: Flat mirror for three.js\n * https://home.adelphi.edu/~stemkoski/ : An implementation of water shader based on the flat mirror\n * http://29a.ch/ && http://29a.ch/slides/2012/webglwater/ : Water shader explanations in WebGL\n */\n\nclass Water extends Mesh {\n\n\tconstructor( geometry, options = {} ) {\n\n\t\tsuper( geometry );\n\n\t\tthis.isWater = true;\n\n\t\tconst scope = this;\n\n\t\tconst textureWidth = options.textureWidth !== undefined ? options.textureWidth : 512;\n\t\tconst textureHeight = options.textureHeight !== undefined ? options.textureHeight : 512;\n\n\t\tconst clipBias = options.clipBias !== undefined ? options.clipBias : 0.0;\n\t\tconst alpha = options.alpha !== undefined ? options.alpha : 1.0;\n\t\tconst time = options.time !== undefined ? options.time : 0.0;\n\t\tconst normalSampler = options.waterNormals !== undefined ? options.waterNormals : null;\n\t\tconst sunDirection = options.sunDirection !== undefined ? options.sunDirection : new Vector3( 0.70707, 0.70707, 0.0 );\n\t\tconst sunColor = new Color( options.sunColor !== undefined ? options.sunColor : 0xffffff );\n\t\tconst waterColor = new Color( options.waterColor !== undefined ? options.waterColor : 0x7F7F7F );\n\t\tconst eye = options.eye !== undefined ? options.eye : new Vector3( 0, 0, 0 );\n\t\tconst distortionScale = options.distortionScale !== undefined ? options.distortionScale : 20.0;\n\t\tconst side = options.side !== undefined ? options.side : FrontSide;\n\t\tconst fog = options.fog !== undefined ? options.fog : false;\n\n\t\t//\n\n\t\tconst mirrorPlane = new Plane();\n\t\tconst normal = new Vector3();\n\t\tconst mirrorWorldPosition = new Vector3();\n\t\tconst cameraWorldPosition = new Vector3();\n\t\tconst rotationMatrix = new Matrix4();\n\t\tconst lookAtPosition = new Vector3( 0, 0, - 1 );\n\t\tconst clipPlane = new Vector4();\n\n\t\tconst view = new Vector3();\n\t\tconst target = new Vector3();\n\t\tconst q = new Vector4();\n\n\t\tconst textureMatrix = new Matrix4();\n\n\t\tconst mirrorCamera = new PerspectiveCamera();\n\n\t\tconst renderTarget = new WebGLRenderTarget( textureWidth, textureHeight );\n\n\t\tconst mirrorShader = {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\t\t\t\tUniformsLib[ 'fog' ],\n\t\t\t\tUniformsLib[ 'lights' ],\n\t\t\t\t{\n\t\t\t\t\t'normalSampler': { value: null },\n\t\t\t\t\t'mirrorSampler': { value: null },\n\t\t\t\t\t'alpha': { value: 1.0 },\n\t\t\t\t\t'time': { value: 0.0 },\n\t\t\t\t\t'size': { value: 1.0 },\n\t\t\t\t\t'distortionScale': { value: 20.0 },\n\t\t\t\t\t'textureMatrix': { value: new Matrix4() },\n\t\t\t\t\t'sunColor': { value: new Color( 0x7F7F7F ) },\n\t\t\t\t\t'sunDirection': { value: new Vector3( 0.70707, 0.70707, 0 ) },\n\t\t\t\t\t'eye': { value: new Vector3() },\n\t\t\t\t\t'waterColor': { value: new Color( 0x555555 ) }\n\t\t\t\t}\n\t\t\t] ),\n\n\t\t\tvertexShader: /* glsl */`\n\t\t\t\tuniform mat4 textureMatrix;\n\t\t\t\tuniform float time;\n\n\t\t\t\tvarying vec4 mirrorCoord;\n\t\t\t\tvarying vec4 worldPosition;\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <shadowmap_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tmirrorCoord = modelMatrix * vec4( position, 1.0 );\n\t\t\t\t\tworldPosition = mirrorCoord.xyzw;\n\t\t\t\t\tmirrorCoord = textureMatrix * mirrorCoord;\n\t\t\t\t\tvec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t#include <beginnormal_vertex>\n\t\t\t\t#include <defaultnormal_vertex>\n\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t#include <fog_vertex>\n\t\t\t\t#include <shadowmap_vertex>\n\t\t\t}`,\n\n\t\t\tfragmentShader: /* glsl */`\n\t\t\t\tuniform sampler2D mirrorSampler;\n\t\t\t\tuniform float alpha;\n\t\t\t\tuniform float time;\n\t\t\t\tuniform float size;\n\t\t\t\tuniform float distortionScale;\n\t\t\t\tuniform sampler2D normalSampler;\n\t\t\t\tuniform vec3 sunColor;\n\t\t\t\tuniform vec3 sunDirection;\n\t\t\t\tuniform vec3 eye;\n\t\t\t\tuniform vec3 waterColor;\n\n\t\t\t\tvarying vec4 mirrorCoord;\n\t\t\t\tvarying vec4 worldPosition;\n\n\t\t\t\tvec4 getNoise( vec2 uv ) {\n\t\t\t\t\tvec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);\n\t\t\t\t\tvec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );\n\t\t\t\t\tvec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );\n\t\t\t\t\tvec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );\n\t\t\t\t\tvec4 noise = texture2D( normalSampler, uv0 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv1 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv2 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv3 );\n\t\t\t\t\treturn noise * 0.5 - 1.0;\n\t\t\t\t}\n\n\t\t\t\tvoid sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {\n\t\t\t\t\tvec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );\n\t\t\t\t\tfloat direction = max( 0.0, dot( eyeDirection, reflection ) );\n\t\t\t\t\tspecularColor += pow( direction, shiny ) * sunColor * spec;\n\t\t\t\t\tdiffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;\n\t\t\t\t}\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <packing>\n\t\t\t\t#include <bsdfs>\n\t\t\t\t#include <fog_pars_fragment>\n\t\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t\t#include <lights_pars_begin>\n\t\t\t\t#include <shadowmap_pars_fragment>\n\t\t\t\t#include <shadowmask_pars_fragment>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#include <logdepthbuf_fragment>\n\t\t\t\t\tvec4 noise = getNoise( worldPosition.xz * size );\n\t\t\t\t\tvec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );\n\n\t\t\t\t\tvec3 diffuseLight = vec3(0.0);\n\t\t\t\t\tvec3 specularLight = vec3(0.0);\n\n\t\t\t\t\tvec3 worldToEye = eye-worldPosition.xyz;\n\t\t\t\t\tvec3 eyeDirection = normalize( worldToEye );\n\t\t\t\t\tsunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );\n\n\t\t\t\t\tfloat distance = length(worldToEye);\n\n\t\t\t\t\tvec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;\n\t\t\t\t\tvec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );\n\n\t\t\t\t\tfloat theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );\n\t\t\t\t\tfloat rf0 = 0.3;\n\t\t\t\t\tfloat reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );\n\t\t\t\t\tvec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;\n\t\t\t\t\tvec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);\n\t\t\t\t\tvec3 outgoingLight = albedo;\n\t\t\t\t\tgl_FragColor = vec4( outgoingLight, alpha );\n\n\t\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t\t#include <fog_fragment>\n\t\t\t\t}`\n\n\t\t};\n\n\t\tconst material = new ShaderMaterial( {\n\t\t\tfragmentShader: mirrorShader.fragmentShader,\n\t\t\tvertexShader: mirrorShader.vertexShader,\n\t\t\tuniforms: UniformsUtils.clone( mirrorShader.uniforms ),\n\t\t\tlights: true,\n\t\t\tside: side,\n\t\t\tfog: fog\n\t\t} );\n\n\t\tmaterial.uniforms[ 'mirrorSampler' ].value = renderTarget.texture;\n\t\tmaterial.uniforms[ 'textureMatrix' ].value = textureMatrix;\n\t\tmaterial.uniforms[ 'alpha' ].value = alpha;\n\t\tmaterial.uniforms[ 'time' ].value = time;\n\t\tmaterial.uniforms[ 'normalSampler' ].value = normalSampler;\n\t\tmaterial.uniforms[ 'sunColor' ].value = sunColor;\n\t\tmaterial.uniforms[ 'waterColor' ].value = waterColor;\n\t\tmaterial.uniforms[ 'sunDirection' ].value = sunDirection;\n\t\tmaterial.uniforms[ 'distortionScale' ].value = distortionScale;\n\n\t\tmaterial.uniforms[ 'eye' ].value = eye;\n\n\t\tscope.material = material;\n\n\t\tscope.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\t\tmirrorWorldPosition.setFromMatrixPosition( scope.matrixWorld );\n\t\t\tcameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );\n\n\t\t\trotationMatrix.extractRotation( scope.matrixWorld );\n\n\t\t\tnormal.set( 0, 0, 1 );\n\t\t\tnormal.applyMatrix4( rotationMatrix );\n\n\t\t\tview.subVectors( mirrorWorldPosition, cameraWorldPosition );\n\n\t\t\t// Avoid rendering when mirror is facing away\n\n\t\t\tif ( view.dot( normal ) > 0 ) return;\n\n\t\t\tview.reflect( normal ).negate();\n\t\t\tview.add( mirrorWorldPosition );\n\n\t\t\trotationMatrix.extractRotation( camera.matrixWorld );\n\n\t\t\tlookAtPosition.set( 0, 0, - 1 );\n\t\t\tlookAtPosition.applyMatrix4( rotationMatrix );\n\t\t\tlookAtPosition.add( cameraWorldPosition );\n\n\t\t\ttarget.subVectors( mirrorWorldPosition, lookAtPosition );\n\t\t\ttarget.reflect( normal ).negate();\n\t\t\ttarget.add( mirrorWorldPosition );\n\n\t\t\tmirrorCamera.position.copy( view );\n\t\t\tmirrorCamera.up.set( 0, 1, 0 );\n\t\t\tmirrorCamera.up.applyMatrix4( rotationMatrix );\n\t\t\tmirrorCamera.up.reflect( normal );\n\t\t\tmirrorCamera.lookAt( target );\n\n\t\t\tmirrorCamera.far = camera.far; // Used in WebGLBackground\n\n\t\t\tmirrorCamera.updateMatrixWorld();\n\t\t\tmirrorCamera.projectionMatrix.copy( camera.projectionMatrix );\n\n\t\t\t// Update the texture matrix\n\t\t\ttextureMatrix.set(\n\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t);\n\t\t\ttextureMatrix.multiply( mirrorCamera.projectionMatrix );\n\t\t\ttextureMatrix.multiply( mirrorCamera.matrixWorldInverse );\n\n\t\t\t// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n\t\t\t// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\t\t\tmirrorPlane.setFromNormalAndCoplanarPoint( normal, mirrorWorldPosition );\n\t\t\tmirrorPlane.applyMatrix4( mirrorCamera.matrixWorldInverse );\n\n\t\t\tclipPlane.set( mirrorPlane.normal.x, mirrorPlane.normal.y, mirrorPlane.normal.z, mirrorPlane.constant );\n\n\t\t\tconst projectionMatrix = mirrorCamera.projectionMatrix;\n\n\t\t\tq.x = ( Math.sign( clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];\n\t\t\tq.y = ( Math.sign( clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];\n\t\t\tq.z = - 1.0;\n\t\t\tq.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];\n\n\t\t\t// Calculate the scaled plane vector\n\t\t\tclipPlane.multiplyScalar( 2.0 / clipPlane.dot( q ) );\n\n\t\t\t// Replacing the third row of the projection matrix\n\t\t\tprojectionMatrix.elements[ 2 ] = clipPlane.x;\n\t\t\tprojectionMatrix.elements[ 6 ] = clipPlane.y;\n\t\t\tprojectionMatrix.elements[ 10 ] = clipPlane.z + 1.0 - clipBias;\n\t\t\tprojectionMatrix.elements[ 14 ] = clipPlane.w;\n\n\t\t\teye.setFromMatrixPosition( camera.matrixWorld );\n\n\t\t\t// Render\n\n\t\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\t\tconst currentXrEnabled = renderer.xr.enabled;\n\t\t\tconst currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n\n\t\t\tscope.visible = false;\n\n\t\t\trenderer.xr.enabled = false; // Avoid camera modification and recursion\n\t\t\trenderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n\t\t\trenderer.setRenderTarget( renderTarget );\n\n\t\t\trenderer.state.buffers.depth.setMask( true ); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n\t\t\tif ( renderer.autoClear === false ) renderer.clear();\n\t\t\trenderer.render( scene, mirrorCamera );\n\n\t\t\tscope.visible = true;\n\n\t\t\trenderer.xr.enabled = currentXrEnabled;\n\t\t\trenderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n\n\t\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\t\t// Restore viewport\n\n\t\t\tconst viewport = camera.viewport;\n\n\t\t\tif ( viewport !== undefined ) {\n\n\t\t\t\trenderer.state.viewport( viewport );\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n}\n\nexport { Water };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}